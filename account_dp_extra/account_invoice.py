# -*- coding: utf-8 -*-
##############################################################################
#
#    OpenERP, Open Source Management Solution
#    Copyright (C) Ian Li @ Elico Corp(<http://www.openerp.net.cn>).
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################

import decimal_precision as dp
from osv import fields, osv

import time

from tools.translate import _


class account_invoice_line(osv.osv):
    _name = 'account.invoice.line'
    _inherit = 'account.invoice.line'
    _description = 'Invoice Line with Different Precision'

    def _amount_line(self, cr, uid, ids, prop, unknow_none, unknow_dict):
        res = {}
        tax_obj = self.pool.get('account.tax')
        cur_obj = self.pool.get('res.currency')
        for line in self.browse(cr, uid, ids):
            price = line.price_unit * (1-(line.discount or 0.0)/100.0)
            taxes = tax_obj.compute_all(
                cr, uid, line.invoice_line_tax_id, price,
                line.quantity, product=line.product_id.id,
                partner=line.invoice_id.partner_id.id)
            res[line.id] = taxes['total']
            if line.invoice_id:
                cur = line.invoice_id.currency_id
                res[line.id] = cur_obj.round(cr, uid, cur, res[line.id])
        return res
    
    _columns = {
        'price_unit': fields.float('Unit Price', required=True, digits_compute= dp.get_precision('Account Line')),
        'price_subtotal': fields.function(_amount_line, method=True, string='Subtotal', type="float",
            digits_compute= dp.get_precision('Account'), store=True),
    }
    
    def move_line_get_item(self, cr, uid, line, context=None):
        dpa = self.pool.get('decimal.precision').precision_get(cr, uid, 'Account')
        return {
            'type':'src',
            'name': line.name[:64],
            'price_unit':line.price_unit,
            'quantity':line.quantity,
            'price':round(line.price_subtotal,dpa),
            'account_id':line.account_id.id,
            'product_id':line.product_id.id,
            'uos_id':line.uos_id.id,
            'account_analytic_id':line.account_analytic_id.id,
            'taxes':line.invoice_line_tax_id,
        }

account_invoice_line()

class account_invoice(osv.osv):
    _name = "account.invoice"
    _inherit = "account.invoice"
    
    #Add 2012-05-03 So to make subtotal in invoice more accurate.
    def _amount_all(self, cr, uid, ids, name, args, context=None):
        res = {}
        
        obj_precision = self.pool.get('decimal.precision')
        prec = obj_precision.precision_get(cr, uid, 'Account')
        
        for invoice in self.browse(cr, uid, ids, context=context):
            res[invoice.id] = {
                'amount_untaxed': 0.0,
                'amount_tax': 0.0,
                'amount_total': 0.0
            }
            for line in invoice.invoice_line:
                res[invoice.id]['amount_untaxed'] += round(line.price_subtotal, prec)
            for line in invoice.tax_line:
                res[invoice.id]['amount_tax'] += round(line.amount, prec)
            res[invoice.id]['amount_total'] = res[invoice.id]['amount_tax'] + res[invoice.id]['amount_untaxed']
        return res
    
    def _get_invoice_line(self, cr, uid, ids, context=None):
        result = {}
        for line in self.pool.get('account.invoice.line').browse(cr, uid, ids, context=context):
            result[line.invoice_id.id] = True
        return result.keys()

    def _get_invoice_tax(self, cr, uid, ids, context=None):
        result = {}
        for tax in self.pool.get('account.invoice.tax').browse(cr, uid, ids, context=context):
            result[tax.invoice_id.id] = True
        return result.keys()
    
    _columns = {
        'amount_untaxed': fields.function(_amount_all, method=True, digits_compute=dp.get_precision('Account'), string='Untaxed',
            store={
                'account.invoice': (lambda self, cr, uid, ids, c={}: ids, ['invoice_line'], 20),
                'account.invoice.tax': (_get_invoice_tax, None, 20),
                'account.invoice.line': (_get_invoice_line, ['price_unit','invoice_line_tax_id','quantity','discount','invoice_id'], 20),
            },
            multi='all'),
        'amount_tax': fields.function(_amount_all, method=True, digits_compute=dp.get_precision('Account'), string='Tax',
            store={
                'account.invoice': (lambda self, cr, uid, ids, c={}: ids, ['invoice_line'], 20),
                'account.invoice.tax': (_get_invoice_tax, None, 20),
                'account.invoice.line': (_get_invoice_line, ['price_unit','invoice_line_tax_id','quantity','discount','invoice_id'], 20),
            },
            multi='all'),
        'amount_total': fields.function(_amount_all, method=True, digits_compute=dp.get_precision('Account'), string='Total',
            store={
                'account.invoice': (lambda self, cr, uid, ids, c={}: ids, ['invoice_line'], 20),
                'account.invoice.tax': (_get_invoice_tax, None, 20),
                'account.invoice.line': (_get_invoice_line, ['price_unit','invoice_line_tax_id','quantity','discount','invoice_id'], 20),
            },
            multi='all'),
    }

account_invoice()

class account_invoice_tax(osv.osv):
    _name = 'account.invoice.tax'
    _inherit = 'account.invoice.tax'
    _description = 'Invoice Tax with Different Precision'

    # add Account Line precision in compute in the return value of computed tax instead of currency's precision,
    # otherwise we will have problem when validate an invoice.
    def compute(self, cr, uid, invoice_id, context=None):
        tax_grouped = {}
        tax_obj = self.pool.get('account.tax')
        cur_obj = self.pool.get('res.currency')
        dp_obj = self.pool.get('decimal.precision')
        inv = self.pool.get('account.invoice').browse(cr, uid, invoice_id, context=context)
        cur = inv.currency_id
        company_currency = inv.company_id.currency_id.id
        
        for line in inv.invoice_line:
            taxes =  tax_obj.compute_all(
                cr, uid, line.invoice_line_tax_id,
                line.price_unit* (1-(line.discount or 0.0)/100.0),
                line.quantity, product=line.product_id.id,
                partner=line.invoice_id.partner_id.id)['taxes']
            for tax in taxes:
                val={}
                val['invoice_id'] = inv.id
                val['name'] = tax['name']
                val['amount'] = tax['amount']
                val['manual'] = False
                val['sequence'] = tax['sequence']
                val['base'] = tax['price_unit'] * line['quantity']
        
                # we need to round first then add!
                # Ian@EC added at 2012-04-28
                dpa = dp_obj.precision_get(cr, uid, 'Account')
                val['amount'] = round(val['amount'], dpa)
                val['base'] = round(val['base'], dpa)
        
                if inv.type in ('out_invoice','in_invoice'):
                    val['base_code_id'] = tax['base_code_id']
                    val['tax_code_id'] = tax['tax_code_id']
                    val['base_amount'] = cur_obj.compute(cr, uid, inv.currency_id.id, company_currency, val['base'] * tax['base_sign'], context={'date': inv.date_invoice or time.strftime('%Y-%m-%d')}, round=False)
                    val['tax_amount'] = cur_obj.compute(cr, uid, inv.currency_id.id, company_currency, val['amount'] * tax['tax_sign'], context={'date': inv.date_invoice or time.strftime('%Y-%m-%d')}, round=False)
                    val['account_id'] = tax['account_collected_id'] or line.account_id.id
                    val['account_analytic_id'] = tax['account_analytic_collected_id']

                else:
                    val['base_code_id'] = tax['ref_base_code_id']
                    val['tax_code_id'] = tax['ref_tax_code_id']
                    val['base_amount'] = cur_obj.compute(cr, uid, inv.currency_id.id, company_currency, val['base'] * tax['ref_base_sign'], context={'date': inv.date_invoice or time.strftime('%Y-%m-%d')}, round=False)
                    val['tax_amount'] = cur_obj.compute(cr, uid, inv.currency_id.id, company_currency, val['amount'] * tax['ref_tax_sign'], context={'date': inv.date_invoice or time.strftime('%Y-%m-%d')}, round=False)
                    val['account_id'] = tax['account_paid_id'] or line.account_id.id
                    val['account_analytic_id'] = tax['account_analytic_paid_id']
                # we need to round first then add!
                # Ian@EC added at 2012-04-28
                val['base_amount'] = round(val['base_amount'], dpa)
                val['tax_amount'] = round(val['tax_amount'], dpa)
                
                key = (val['tax_code_id'], val['base_code_id'], val['account_id'],  val['account_analytic_id'])
                if not key in tax_grouped:
                    tax_grouped[key] = val
                else:
                    tax_grouped[key]['amount'] += val['amount']
                    tax_grouped[key]['base'] += val['base']
                    tax_grouped[key]['base_amount'] += val['base_amount']
                    tax_grouped[key]['tax_amount'] += val['tax_amount']
        
        
        for t in tax_grouped.values():
            t['base'] = cur_obj.round(cr, uid, cur, t['base'])
            t['amount'] = cur_obj.round(cr, uid, cur, t['amount'])
            t['base_amount'] = cur_obj.round(cr, uid, cur, t['base_amount'])
            t['tax_amount'] = cur_obj.round(cr, uid, cur, t['tax_amount'])
        return tax_grouped
    
account_invoice_tax()

# Following add 2012-03-31 to avoiding warnings when create account_voucher. Refer to the email on 2012-03-28.
# On 2012-04-26, take out for supplier payment validate.
# Added back on 2012-04-27, and added round on amount = round(line.move_line_id.amount_residual,dpa) or we can't validate supplier payment.
# class account_voucher(osv.osv):
    
#     _inherit = 'account.voucher'

#     def action_move_line_create(self, cr, uid, ids, context=None):

#         def _get_payment_term_lines(term_id, amount):
#             term_pool = self.pool.get('account.payment.term')
#             if term_id and amount:
#                 terms = term_pool.compute(cr, uid, term_id, amount)
#                 return terms
#             return False
#         if context is None:
#             context = {}
#         move_pool = self.pool.get('account.move')
#         move_line_pool = self.pool.get('account.move.line')
#         currency_pool = self.pool.get('res.currency')
#         tax_obj = self.pool.get('account.tax')
#         seq_obj = self.pool.get('ir.sequence')        
#         dp_obj = self.pool.get('decimal.precision')
        
#         dpa = dp_obj.precision_get(cr, uid, 'Account') # Get the precision for Account.
        
#         for inv in self.browse(cr, uid, ids, context=context):
#             if inv.move_id:
#                 continue
#             context_multi_currency = context.copy()
#             context_multi_currency.update({'date': inv.date})

#             if inv.number:
#                 name = inv.number
#             elif inv.journal_id.sequence_id:
#                 name = seq_obj.get_id(cr, uid, inv.journal_id.sequence_id.id)
#             if not name:
#                 raise osv.except_osv(_('Error !'), _('Please define a sequence on the journal and make sure it is activated !'))
#             if not inv.reference:
#                 ref = name.replace('/','')
#             else:
#                 ref = inv.reference

#             move = {
#                 'name': name,
#                 'journal_id': inv.journal_id.id,
#                 'narration': inv.narration,
#                 'date': inv.date,
#                 'ref': ref,
#                 'period_id': inv.period_id and inv.period_id.id or False
#             }
#             move_id = move_pool.create(cr, uid, move)

#             #create the first line manually
#             company_currency = inv.journal_id.company_id.currency_id.id
#             current_currency = inv.currency_id.id
#             debit = 0.0
#             credit = 0.0
#             # TODO: is there any other alternative then the voucher type ??
#             # -for sale, purchase we have but for the payment and receipt we do not have as based on the bank/cash journal we can not know its payment or receipt
#             if inv.type in ('purchase', 'payment'):
#                 credit = round(currency_pool.compute(cr, uid, current_currency, company_currency, inv.amount, context=context_multi_currency), dpa)
#             elif inv.type in ('sale', 'receipt'):
#                 debit = round(currency_pool.compute(cr, uid, current_currency, company_currency, inv.amount, context=context_multi_currency), dpa)
#             if debit < 0:
#                 credit = -debit
#                 debit = 0.0
#             if credit < 0:
#                 debit = -credit
#                 credit = 0.0
#             sign = debit - credit < 0 and -1 or 1
#             #create the first line of the voucher
#             move_line = {
#                 'name': inv.name or '/',
#                 'debit': debit,
#                 'credit': credit,
#                 'account_id': inv.account_id.id,
#                 'move_id': move_id,
#                 'journal_id': inv.journal_id.id,
#                 'period_id': inv.period_id.id,
#                 'partner_id': inv.partner_id.id,
#                 'currency_id': company_currency <> current_currency and  current_currency or False,
#                 'amount_currency': company_currency <> current_currency and sign * inv.amount or 0.0,
#                 'date': inv.date,
#                 'date_maturity': inv.date_due
#             }
#             move_line_pool.create(cr, uid, move_line)
#             rec_list_ids = []
#             line_total = debit - credit
#             if inv.type == 'sale':
#                 line_total = line_total - round(currency_pool.compute(cr, uid, inv.currency_id.id, company_currency, inv.tax_amount, context=context_multi_currency), dpa)
#             elif inv.type == 'purchase':
#                 line_total = line_total + round(currency_pool.compute(cr, uid, inv.currency_id.id, company_currency, inv.tax_amount, context=context_multi_currency), dpa)

#             for line in inv.line_ids:
#                 #create one move line per voucher line where amount is not 0.0
#                 if not line.amount:
#                     continue
#                 #we check if the voucher line is fully paid or not and create a move line to balance the payment and initial invoice if needed
#                 if line.amount == line.amount_unreconciled:
#                     amount = round(line.move_line_id.amount_residual,dpa) #residual amount in company currency
#                 else:
#                     amount = round(currency_pool.compute(cr, uid, current_currency, company_currency, line.untax_amount or line.amount, context=context_multi_currency), dpa)
#                 move_line = {
#                     'journal_id': inv.journal_id.id,
#                     'period_id': inv.period_id.id,
#                     'name': line.name and line.name or '/',
#                     'account_id': line.account_id.id,
#                     'move_id': move_id,
#                     'partner_id': inv.partner_id.id,
#                     'currency_id': company_currency <> current_currency and current_currency or False,
#                     'analytic_account_id': line.account_analytic_id and line.account_analytic_id.id or False,
#                     'quantity': 1,
#                     'credit': 0.0,
#                     'debit': 0.0,
#                     'date': inv.date
#                 }
#                 if not amount:
#                     raise osv.except_osv(_('Warning'),
#                         _("Error while processing 'account.voucher %s' (id:%s) for partner '%s', amount: %s !") % (inv.name, inv.id, inv.partner_id.name, inv.amount))
#                 if amount < 0:
#                     amount = -amount
#                     if line.type == 'dr':
#                         line.type = 'cr'
#                     else:
#                         line.type = 'dr'

#                 if (line.type=='dr'):
#                     line_total += amount
#                     move_line['debit'] = amount
#                 else:
#                     line_total -= amount
#                     move_line['credit'] = amount

#                 if inv.tax_id and inv.type in ('sale', 'purchase'):
#                     move_line.update({
#                         'account_tax_id': inv.tax_id.id,
#                     })
#                 if move_line.get('account_tax_id', False):
#                     tax_data = tax_obj.browse(cr, uid, [move_line['account_tax_id']], context=context)[0]
#                     if not (tax_data.base_code_id and tax_data.tax_code_id):
#                         raise osv.except_osv(_('No Account Base Code and Account Tax Code!'),_("You have to configure account base code and account tax code on the '%s' tax!") % (tax_data.name))
#                 sign = (move_line['debit'] - move_line['credit']) < 0 and -1 or 1
#                 move_line['amount_currency'] = company_currency <> current_currency and sign * line.amount or 0.0
#                 voucher_line = move_line_pool.create(cr, uid, move_line)
#                 if line.move_line_id.id:
#                     rec_ids = [voucher_line, line.move_line_id.id]
#                     rec_list_ids.append(rec_ids)

#             inv_currency_id = inv.currency_id or inv.journal_id.currency or inv.journal_id.company_id.currency_id
#             if not currency_pool.is_zero(cr, uid, inv_currency_id, line_total):
#                 diff = line_total
#                 account_id = False
#                 if inv.payment_option == 'with_writeoff':
#                     account_id = inv.writeoff_acc_id.id
#                 elif inv.type in ('sale', 'receipt'):
#                     account_id = inv.partner_id.property_account_receivable.id
#                 else:
#                     account_id = inv.partner_id.property_account_payable.id
#                 move_line = {
#                     'name': name,
#                     'account_id': account_id,
#                     'move_id': move_id,
#                     'partner_id': inv.partner_id.id,
#                     'date': inv.date,
#                     'credit': diff > 0 and diff or 0.0,
#                     'debit': diff < 0 and -diff or 0.0,
#                     #'amount_currency': company_currency <> current_currency and currency_pool.compute(cr, uid, company_currency, current_currency, diff * -1, context=context_multi_currency) or 0.0,
#                     #'currency_id': company_currency <> current_currency and current_currency or False,
#                 }
#                 move_line_pool.create(cr, uid, move_line)
#             self.write(cr, uid, [inv.id], {
#                 'move_id': move_id,
#                 'state': 'posted',
#                 'number': name,
#             })
#             move_pool.post(cr, uid, [move_id], context={})
#             for rec_ids in rec_list_ids:
#                 if len(rec_ids) >= 2:
#                     move_line_pool.reconcile_partial(cr, uid, rec_ids)
#         return True

# account_voucher()
